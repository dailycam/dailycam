# 2. 데이터베이스 스키마 설계 (SQLAlchemy Model)

## 개요

이미 존재하는 [User](file:///c:/dev/dailycam-main/backend/app/models/user.py#8-35) 모델과 연동하여 AI 분석 데이터를 저장하기 위한 4개의 새로운 테이블을 설계합니다.

## 1. AnalysisLog 테이블

VLM 분석 결과 JSON 원본과 핵심 메타데이터를 저장합니다.

```python
"""Analysis log model for storing VLM video analysis results"""

from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, JSON, Float
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.database import Base


class AnalysisLog(Base):
    """VLM 비디오 분석 결과 저장 모델"""
    __tablename__ = "analysis_logs"
    
    # 기본 컬럼
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # 영상 정보
    video_filename = Column(String(500), nullable=True, comment="원본 영상 파일명")
    video_path = Column(String(1000), nullable=True, comment="영상 저장 경로 (S3 등)")
    video_duration_seconds = Column(Float, nullable=True, comment="영상 길이 (초)")
    
    # VLM 분석 원본 데이터 (JSON)
    analysis_result = Column(JSON, nullable=False, comment="VLM 분석 결과 전체 JSON")
    
    # 핵심 메타데이터 (빠른 조회를 위해 별도 컬럼으로 저장)
    assumed_stage = Column(String(50), nullable=True, index=True, comment="추정 발달 단계")
    age_months = Column(Integer, nullable=True, comment="아이 개월 수")
    safety_score = Column(Integer, nullable=True, index=True, comment="안전 점수 (0-100)")
    overall_safety_level = Column(String(50), nullable=True, comment="전체 안전도 레벨")
    
    # AI 설정 파라미터
    ai_temperature = Column(Float, nullable=True, comment="AI Temperature 설정값")
    ai_top_k = Column(Integer, nullable=True, comment="AI Top-K 설정값")
    ai_top_p = Column(Float, nullable=True, comment="AI Top-P 설정값")
    
    # 타임스탬프
    created_at = Column(DateTime(timezone=True), server_default=func.now(), index=True)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    user = relationship("User", backref="analysis_logs")
    
    def __repr__(self):
        return f"<AnalysisLog(id={self.id}, user_id={self.user_id}, stage={self.assumed_stage}, safety={self.safety_score})>"
```

**설계 근거:**
- [VideoAnalysisTest.tsx](file:///c:/dev/dailycam-main/frontend/src/pages/VideoAnalysisTest.tsx)의 `analysisResult` 객체 전체를 `analysis_result` JSON 컬럼에 저장
- 자주 조회/필터링되는 데이터(`assumed_stage`, `safety_score`)는 별도 컬럼으로 중복 저장하여 쿼리 성능 향상
- `user_id` FK로 User 테이블과 연결
- CASCADE DELETE로 사용자 삭제 시 분석 로그도 함께 삭제

---

## 2. DailySummary 테이블

Dashboard의 주간/월간 차트용 통계 데이터를 일자별로 집계하여 저장합니다.

```python
"""Daily summary model for dashboard statistics"""

from sqlalchemy import Column, Integer, Date, DateTime, ForeignKey, Float, String
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.database import Base


class DailySummary(Base):
    """대시보드 통계용 일별 요약 데이터 모델"""
    __tablename__ = "daily_summaries"
    
    # 기본 컬럼
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    summary_date = Column(Date, nullable=False, index=True, comment="요약 날짜")
    
    # 안전 통계
    avg_safety_score = Column(Float, nullable=True, comment="일평균 안전 점수")
    min_safety_score = Column(Float, nullable=True, comment="일최저 안전 점수")
    max_safety_score = Column(Float, nullable=True, comment="일최고 안전 점수")
    
    # 이벤트 감지 횟수
    total_incident_count = Column(Integer, default=0, comment="전체 사건 감지 횟수")
    danger_count = Column(Integer, default=0, comment="위험 등급 사건 수")
    warning_count = Column(Integer, default=0, comment="주의 등급 사건 수")
    info_count = Column(Integer, default=0, comment="정보 등급 사건 수")
    
    # 발달 통계
    avg_development_score = Column(Float, nullable=True, comment="일평균 발달 점수")
    total_development_events = Column(Integer, default=0, comment="발달 행동 관찰 횟수")
    
    # 발달 영역별 감지 횟수 (DevelopmentReport 차트용)
    language_count = Column(Integer, default=0, comment="언어 발달 관찰 횟수")
    motor_count = Column(Integer, default=0, comment="운동 발달 관찰 횟수")
    cognitive_count = Column(Integer, default=0, comment="인지 발달 관찰 횟수")
    social_count = Column(Integer, default=0, comment="사회성 발달 관찰 횟수")
    emotional_count = Column(Integer, default=0, comment="정서 발달 관찰 횟수")
    
    # 모니터링 시간
    monitoring_hours = Column(Float, nullable=True, comment="모니터링 시간 (시간)")
    
    # 타임스탬프
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    user = relationship("User", backref="daily_summaries")
    
    # Unique constraint: 한 사용자당 하루에 하나의 요약만 존재
    __table_args__ = (
        {"mysql_charset": "utf8mb4", "mysql_collate": "utf8mb4_unicode_ci"},
    )
    
    def __repr__(self):
        return f"<DailySummary(user_id={self.user_id}, date={self.summary_date}, safety={self.avg_safety_score})>"
```

**설계 근거:**
- [Dashboard.tsx](file:///c:/dev/dailycam-main/frontend/src/pages/Dashboard.tsx)의 차트 데이터 요구사항을 반영:
  - 시간대별 안전/발달 점수 추이
  - 주간/월간 통계
  - 이벤트 감지 횟수
- [SafetyReport.tsx](file:///c:/dev/dailycam-main/frontend/src/pages/SafetyReport.tsx)의 주간/월간 차트에도 사용
- [DevelopmentReport.tsx](file:///c:/dev/dailycam-main/frontend/src/pages/DevelopmentReport.tsx)의 영역별 발달 빈도 차트에 사용
- 집계 데이터를 미리 계산하여 저장함으로써 대시보드 로딩 속도 향상

**인덱스 전략:**
```python
from sqlalchemy import Index

# 복합 인덱스 추가 (쿼리 최적화)
Index('idx_user_date', DailySummary.user_id, DailySummary.summary_date, unique=True)
```

---

## 3. HighlightClip 테이블

ClipHighlights 페이지에 표시될 영상 클립 정보를 저장합니다.

```python
"""Highlight clip model for storing important video moments"""

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Float, Text, Enum as SQLEnum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.database import Base
import enum


class ClipCategory(str, enum.Enum):
    """클립 카테고리"""
    DEVELOPMENT = "development"  # 발달 클립
    SAFETY = "safety"  # 안전 클립


class ClipImportance(str, enum.Enum):
    """클립 중요도"""
    HIGH = "high"  # 높음 (초록)
    MEDIUM = "medium"  # 중간 (파랑)
    WARNING = "warning"  # 주의 (노랑)
    INFO = "info"  # 정보 (회색)


class HighlightClip(Base):
    """하이라이트 클립 정보 모델"""
    __tablename__ = "highlight_clips"
    
    # 기본 컬럼
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    analysis_log_id = Column(Integer, ForeignKey("analysis_logs.id", ondelete="CASCADE"), nullable=True, comment="원본 분석 로그 ID")
    
    # 클립 정보
    title = Column(String(200), nullable=False, comment="클립 제목")
    description = Column(Text, nullable=True, comment="클립 설명")
    category = Column(SQLEnum(ClipCategory), nullable=False, index=True, comment="카테고리 (발달/안전)")
    subcategory = Column(String(100), nullable=True, comment="세부 카테고리 (운동 발달, 언어 발달 등)")
    
    # 영상 정보
    video_path = Column(String(1000), nullable=True, comment="클립 영상 경로")
    thumbnail_path = Column(String(1000), nullable=True, comment="썸네일 이미지 경로")
    thumbnail_emoji = Column(String(10), nullable=True, comment="썸네일 이모지 (프론트용)")
    duration_seconds = Column(Float, nullable=True, comment="클립 길이 (초)")
    timestamp_start = Column(String(20), nullable=True, comment="원본 영상 시작 시간 (00:02:15)")
    timestamp_end = Column(String(20), nullable=True, comment="원본 영상 종료 시간 (00:02:45)")
    
    # 중요도 및 태그
    importance = Column(SQLEnum(ClipImportance), nullable=False, index=True, comment="중요도")
    tags = Column(String(500), nullable=True, comment="태그 (쉼표 구분)")
    
    # 메타데이터
    clip_timestamp = Column(DateTime(timezone=True), nullable=False, comment="클립 발생 시각")
    created_at = Column(DateTime(timezone=True), server_default=func.now(), index=True)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    user = relationship("User", backref="highlight_clips")
    analysis_log = relationship("AnalysisLog", backref="highlight_clips")
    
    def __repr__(self):
        return f"<HighlightClip(id={self.id}, title={self.title}, category={self.category})>"
```

**설계 근거:**
- [ClipHighlights.tsx](file:///c:/dev/dailycam-main/frontend/src/pages/ClipHighlights.tsx)의 데이터 구조를 완벽히 반영:
  - `developmentClips`와 `safetyClips` 배열 구조
  - 썸네일 이모지, duration, timestamp 등 모든 필드 포함
- `analysis_log_id` FK로 원본 분석 로그와 연결 (선택사항)
- Enum 타입으로 카테고리/중요도 관리하여 데이터 일관성 확보

---

## 4. SafetyEvent 테이블 설계 결정

### 옵션 분석

#### 옵션 A: JSON으로 통째로 저장 (AnalysisLog 내)

**장점:**
- 구현 간단
- VLM 출력 그대로 저장하므로 데이터 손실 없음
- 스키마 변경 시 유연함

**단점:**
- 특정 이벤트 검색/필터링이 어려움
- 통계 집계 쿼리 성능이 낮음
- 인덱싱 불가능

#### 옵션 B: 별도 테이블로 분리 ✅ **권장**

**장점:**
- 이벤트별 검색/필터링 가능
- 타임라인 조회 성능 우수
- 통계 집계 용이
- 심각도별, 시간대별 인덱싱 가능

**단점:**
- 구현 복잡도 증가
- 스키마 변경 시 마이그레이션 필요

### 권장 설계: SafetyEvent 테이블

```python
"""Safety event model for timeline and incident tracking"""

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text, Boolean, Enum as SQLEnum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.database import Base
import enum


class EventSeverity(str, enum.Enum):
    """사건 심각도"""
    ACCIDENT = "사고"  # 실제 사고 발생
    DANGER = "위험"  # 위험 상황
    WARNING = "주의"  # 주의 필요
    RECOMMEND = "권장"  # 권장 사항


class EventType(str, enum.Enum):
    """사건 유형"""
    FALL = "낙상"
    COLLISION = "충돌"
    EDGE_APPROACH = "침대가장자리"
    ACTIVE_MOVEMENT = "활발한움직임"
    SLEEP_POSTURE = "수면자세"
    OTHER = "기타"


class SafetyEvent(Base):
    """안전 사건/이벤트 모델 (타임라인용)"""
    __tablename__ = "safety_events"
    
    # 기본 컬럼
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    analysis_log_id = Column(Integer, ForeignKey("analysis_logs.id", ondelete="CASCADE"), nullable=True, comment="원본 분석 로그 ID")
    
    # 사건 정보
    severity = Column(SQLEnum(EventSeverity), nullable=False, index=True, comment="심각도")
    event_type = Column(SQLEnum(EventType), nullable=False, index=True, comment="사건 유형")
    description = Column(Text, nullable=False, comment="사건 설명")
    
    # 시간 정보
    timestamp_range = Column(String(50), nullable=True, comment="발생 시간대 (00:02:15-00:02:45)")
    event_hour = Column(Integer, nullable=True, index=True, comment="발생 시각 (시)")
    event_timestamp = Column(DateTime(timezone=True), nullable=False, index=True, comment="사건 발생 시각")
    
    # 안전 장치 및 결과
    has_safety_device = Column(Boolean, nullable=True, comment="안전장치 유무")
    estimated_outcome = Column(String(200), nullable=True, comment="예상 결과")
    resolved = Column(Boolean, default=False, comment="해결 여부")
    
    # 클립 연동
    has_clip = Column(Boolean, default=False, comment="클립 저장 여부")
    highlight_clip_id = Column(Integer, ForeignKey("highlight_clips.id", ondelete="SET NULL"), nullable=True)
    
    # 타임스탬프
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    user = relationship("User", backref="safety_events")
    analysis_log = relationship("AnalysisLog", backref="safety_events")
    highlight_clip = relationship("HighlightClip", backref="related_event")
    
    def __repr__(self):
        return f"<SafetyEvent(id={self.id}, type={self.event_type}, severity={self.severity})>"
```

**설계 근거:**
- [Dashboard.tsx](file:///c:/dev/dailycam-main/frontend/src/pages/Dashboard.tsx)의 타임라인 이벤트 요구사항 반영:
  - `timelineEvents` 배열 구조
  - 시간대별 필터링 (`event_hour`)
  - 심각도별 색상 구분
- [SafetyReport.tsx](file:///c:/dev/dailycam-main/frontend/src/pages/SafetyReport.tsx)의 24시간 시계 차트용 시간대별 집계
- [VideoAnalysisTest.tsx](file:///c:/dev/dailycam-main/frontend/src/pages/VideoAnalysisTest.tsx)의 `incident_events`, `critical_events` 데이터

**인덱스 전략:**
```python
from sqlalchemy import Index

# 복합 인덱스
Index('idx_user_severity_date', SafetyEvent.user_id, SafetyEvent.severity, SafetyEvent.event_timestamp)
Index('idx_user_hour', SafetyEvent.user_id, SafetyEvent.event_hour)
```

---

## 테이블 관계 다이어그램

```
User (기존)
  ├─ analysis_logs (1:N)
  ├─ daily_summaries (1:N)
  ├─ highlight_clips (1:N)
  └─ safety_events (1:N)

AnalysisLog
  ├─ highlight_clips (1:N)
  └─ safety_events (1:N)

HighlightClip
  └─ related_event (1:1, SafetyEvent)
```

---

## 마이그레이션 스크립트 생성 방법

```bash
# Alembic 마이그레이션 생성
alembic revision --autogenerate -m "Add AI analysis tables"

# 마이그레이션 적용
alembic upgrade head
```

---

## 성능 최적화 권장사항

### 1. 데이터 보관 정책
```python
# DailySummary: 1년 보관 후 아카이빙
# AnalysisLog: 30일 보관 후 JSON 압축 또는 삭제
# HighlightClip: 90일 보관
# SafetyEvent: 90일 보관
```

### 2. 파티셔닝 (대용량 데이터 시)
```sql
-- MySQL 8.0+ 파티셔닝 예시
ALTER TABLE analysis_logs
PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

### 3. 정기 집계 작업
```python
# Celery Beat 스케줄러로 매일 자정 DailySummary 집계
@celery.task
def aggregate_daily_summary(date: datetime.date):
    """AnalysisLog에서 DailySummary 집계"""
    # 구현...
```

---

## 추가 고려사항

### 발달 기술 추적 (선택사항)

발달 기술을 별도 테이블로 관리하려면:

```python
class DevelopmentSkill(Base):
    """발달 기술 추적 테이블"""
    __tablename__ = "development_skills"
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    analysis_log_id = Column(Integer, ForeignKey("analysis_logs.id"))
    
    skill_name = Column(String(200), nullable=False)
    skill_category = Column(String(50), nullable=False)  # 운동/언어/인지/사회성/정서
    present = Column(Boolean, default=True)
    frequency = Column(Integer, nullable=True)
    skill_level = Column(String(50), nullable=True)
    
    observed_at = Column(DateTime(timezone=True), server_default=func.now())
```

하지만 현재는 `AnalysisLog`의 JSON에 포함되어 있으므로 별도 테이블은 불필요할 수 있습니다.
